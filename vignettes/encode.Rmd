---
title: "Advanced Bioconductor: working with ENCODE"
author: "Vincent J. Carey, stvjc at channing.harvard.edu"
date: "`r format(Sys.time(), '%B %d, %Y')`"
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Working with ENCODE}
  %\VignetteEncoding{UTF-8}
output:
  BiocStyle::html_document:
    highlight: pygments
    number_sections: yes
    theme: united
    toc: yes
    toc_depth: 3
---

```{r setup,echo=FALSE,results="hide"}
suppressMessages({
suppressPackageStartupMessages({
library(AnnotationHub)
library(rtracklayer)
library(DT)
library(tibble)
library(BiocStyle)
})
})
```

# Introduction

The Encyclopedia of DNA Elements (ENCODE) is a collection of
experimental results and computing resources devoted to elaboration
of mechanisms of gene regulation.  The project [main page](https://www.encodeproject.org/)
is a good overview of its scope, involving four main organisms (human, mouse, worm
and fly) and dozens of biotechnological innovations that
are used to analyze gene structure and
regulation.  In this section we will illustrate ways of using Bioconductor
to acquire and interpret ENCODE resources.

# Built-in surveys through ENCODExplorer metadata

We can use AnnotationHub to get information on ENCODE results that have
been curated for direct use with Bioconductor.  The
`r Biocpkg("ENCODExplorer")` package provides a metadata table,
that we retrieve using `r Biocpkg("AnnotationHub")`.  We use
the "full" table because it provides links to raw and processed data files
curated in the cloud by the ENCODE project.  

## Using a local metadata cache 

This table is over 90MB in
size, so it takes a few moments to download from cloud or load from cache.

```{r doen1,cache=TRUE}
library(AnnotationHub)
ah = AnnotationHub()
query(ah, "ENCODExplorerData")
fm = ah[["AH75132"]]
dim(fm)
table(fm$organism)
```

## Filtering the metadata table

We focus on human samples, and limit to ChIP-seq
experiments for now.
```{r doen2, cache=TRUE}
# filter
hfm = fm[which(fm$organism == "Homo sapiens"),]
tail(sort(table(hfm$assay)))
hfmt = hfm[which(hfm$assay == "TF ChIP-seq"),]
```

The proteins for which binding patterns can be
assessed are in the `antibody_target` field:
```{r lkst}
tail(sort(table(hfmt$antibody_target)))
```

## Managing the information with a GenomicFiles instance 

We'll manage the ChIP-seq data references with a
`r Biocpkg("GenomicFiles")` object.
For convenience, we'll focus on bigWig files.

```{r dolim}
hfmtbw = hfmt[hfmt$file_type == "bigWig",]
dim(hfmtbw)
table(hfmtbw$output_type)
```
<!--
Note that IDR denotes "irreproducible discovery rate" a measure of
confidence [developed within ENCODE](https://genome.ucsc.edu/ENCODE/qualityMetrics.html).
-->
```{r dogf}
library(GenomicFiles)
gf1 = GenomicFiles(files=hfmtbw$cloud_metadata.url)
colData(gf1) = as(as.data.frame(hfmtbw), "DataFrame")
table(gf1$assembly)
```
This last table is very important, indicating that we are managing information
for which two genomic coordinate systems are in play.  In the introduction
to Bioconductor, it is shown
how `liftOver` can be used to translate between coordinate systems if needed.

We'll focus on data collected with GRCh38 coordinates.
```{r limg}
gf1 = gf1[, which(gf1$assembly == "GRCh38")]
gf1
gf = GenomicFiles(files=hfmtbw$cloud_metadata.url)
colData(gf) = as(as.data.frame(hfmtbw), "DataFrame")
```

## Anatomic sources of samples

We'll define a helper function to report on discrete properties
of samples.  This gives us clues on the contents of listings of biosample type and
associated ontology labels.
```{r lktls}
tls = function(x) tail(sort(table(x)))
tls(gf1$biosample_name)
tls(gf1$biosample_ontology)
```

The use of ontology labeling helps us to organize information on samples.
Bioconductor's `r Biocpkg("ontoProc")` package can be used to
develop a simple hierarchical display.  We focus on the Experimental Factor
Ontology (EFO) tags, and take a very small subset of tags in use to
obtain a tractable display in this document.
```{r lkontopl}
library(ontoProc)
ee = getEFOOnto()
tail(sort(table(hfmt$biosample_ontology)),12) -> ioi
nn = names(ioi[grep("EFO", names(ioi))])
tails = gsub(".*_", "", nn)
tailss = gsub("/", "", tails)
tt = paste0("EFO:", tailss)
onto_plot2(ee, tt, cex=.6)
```

## Targeted sketching of peak scores

We'll focus on the transcription factor CREB1.
There are a modest number of samples in different
cell lines.  Some are treated with ethanol.
```{r lktr}
gf1_creb1 = gf1[, which(gf1$target == "CREB1")]
table(gf1_creb1$treatment, gf1_creb1$biosample_name, exclude=NULL)
```
We'll focus on samples with type `signal p-value`.
```{r lkopt}
table(gf1_creb1$output_type, gf1_creb1$biosample_name, exclude=NULL)
gf1_creb1_use = gf1_creb1[, 
   which(gf1_creb1$output_type == "signal p-value")]
```
We will import a megabase of bigWig content from the
files selected in this way, using `reduceByFile`:
```{r dored,cache=TRUE}
myr = GRanges("chr17", IRanges(66e6,67e6))
genome(myr) = "GRCh38"
rowRanges(gf1_creb1_use) = myr
sels = reduceByFile(gf1_creb1_use, MAP=function(range, file, ...) {
    sel = BigWigSelection(range)
    import.bw(file, selection=sel, genome=genome(myr)[1])
})
```
Here is our targeted sketch:
```{r lkres1}
lk1 = sels[[1]][[1]]
lk2 = sels[[2]][[1]]
plot(start(lk1)+.5*(width(lk1)), lk1$score, pch=19,
 xlab="midpoint of scored interval, chr17", ylab="-log10 CREB1 signal p-value",
 cex=.5, col=lava::Col("black", alpha=.3))
points(start(lk2)+.5*width(lk2), lk2$score, pch=19, 
 col=lava::Col("blue", alpha=.3), cex=.5)
```

## Exercises

### Basic descriptive statistics

1. `gf1` represents data on `r ncol(gf1)` ChIP-seq experiments in
bigWig format.  Use
the `cloud_metadata.file_size` `colData` component to state a) the median file size, and b) 
the total number of gigabytes of cloud-resident data to which `gf1` mediates access.

2. What is the most common ChIP-seq target protein studied in the `r ncol(gf1)`
experiments?

3. What is the most commonly studied cell type in the `r ncol(gf1)`
experiments?

4. Use the `fm` metadata table.  For the application of the ATAC-seq assay
to human samples, what is the most common `biosample_name`?

```
 as_tibble(fm) %>% dplyr::filter(assay == "ATAC-seq" & organism=="Homo sapiens") %>% 
    dplyr::select(biosample_name) %>% group_by(biosample_name) %>%
    summarise(n=dplyr::n()) %>% arrange(desc(n))
```

### Retention of metadata; plotting

The following function, annotated in roxygen format,
gathers the task of filtering bigWig data of a specific
output type and target in a given genomic interval.

```{r doimpsource}
#' import bigwig in an interval, given GenomicFiles for ENCODE bigWig files
#' @param gf GenomicFiles instance
#' @param target character(1) ChIP-seq target
#' @param biosample_names character() vector of cell types to retain
#' @param output_type character(1) defaults to "signal p-value"
#' @param selection GRanges instance, one range allowed
#' @export
 import_enc_bw = function(gf, target="CREB1", 
   biosample_names = c("HepG2", "MCF-7", "A549"), output_type="signal p-value",
   selection= GRanges("chr17", IRanges(66e6,67e6), genome="GRCh38")) {
  stopifnot(length(selection)==1)
  gf_use = gf[, which(gf$target == target)]
  gf_use = gf_use[, 
     which(gf_use$output_type == "signal p-value")]
  gf_use = gf_use[, 
     which(gf_use$biosample_name %in% biosample_names)]
  rowRanges(gf_use) = selection
  ans = reduceByFile(gf_use, MAP=function(range, file, ...) {
      sel = BigWigSelection(range)
      import.bw(file, selection=sel, genome=genome(myr)[1])
  })
  ans = GRangesList(unlist(ans, recursive=FALSE))
  mcols(ans) = colData(gf_use)
  ans
}
```
We can generate our sketch data with a pair of simple calls,
assuming the construction of `gf1` is accomplished as
above.

First, we generate the requested data on the available biosamples.
```{r redosk,cache=TRUE}
skd = import_enc_bw(gf1)
```
A virtue of this approach is that the cell types (and
all metadata) are bound to the scores:
```{r lkskmet}
table(mcols(skd)$biosample_name)
```
To complete the task, we define a plotting function.
We'll call it to compare HepG2 and MCF-7 patterns in the selected interval.
```{r doplp}
plot_pair = function(impeb, ylim=c(0,500), xlim=c(66.1e6,66.3e6),
    logy=TRUE, leg_frac_x=.015) {
  stopifnot(length(impeb)==2)
  lk1 = impeb[[1]]
  lk2 = impeb[[2]]
  if (logy) {
   lk1 = lk1[which(lk1$score>0)]
   lk2 = lk2[which(lk2$score>0)]
   }
  seqn = as.character(seqnames(impeb[[1]]))[1]
  g = grep("chr", seqn)
  if (length(g)==0) seqn=paste0("chr", seqn)
  targ = mcols(impeb)$target[1]
  oty = mcols(impeb)$output_type[1]
  pspec = list(x=start(lk1)+.5*(width(lk1)), y=lk1$score, pch=19,
   xlab=sprintf("midpoint of scored interval, %s", seqn), ylab=sprintf("bigWig '%s' for %s", oty, targ),
   cex=.5, col=lava::Col("orange", alpha=.1), ylim=ylim, xlim=xlim, log=ifelse(logy, "y", ""))
  do.call(plot, pspec)
  points(start(lk2)+.5*width(lk2), lk2$score, pch=19, 
   col=lava::Col("blue", alpha=.1), cex=.5)
  legend(xlim[1]+leg_frac_x*diff(xlim), ylim[2], pch=19, col=lava::Col(c("orange", "blue"), alpha=.1),
    legend=mcols(impeb)$biosample_name)
}
plot_pair(skd[5:6], ylim=c(1,1500), xlim=c(66e6, 67e6), leg_frac_x=.04)
plot_pair(skd[c(4,7)], ylim=c(1,1500), xlim=c(66e6, 67e6), leg_frac_x=.04)
```
