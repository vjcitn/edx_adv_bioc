---
title: "Advanced Bioconductor: working with ENCODE"
author: "Vincent J. Carey, stvjc at channing.harvard.edu"
date: "`r format(Sys.time(), '%B %d, %Y')`"
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Working with ENCODE}
  %\VignetteEncoding{UTF-8}
output:
  BiocStyle::html_document:
    highlight: pygments
    number_sections: yes
    theme: united
    toc: yes
    toc_depth: 3
---

```{r setup,echo=FALSE,results="hide"}
suppressMessages({
suppressPackageStartupMessages({
library(AnnotationHub)
library(rtracklayer)
library(DT)
library(tibble)
library(BiocStyle)
})
})
```

# Introduction

The Encyclopedia of DNA Elements (ENCODE) is a collection of
experimental results and computing resources devoted to elaboration
of mechanisms of gene regulation.  The project [main page](https://www.encodeproject.org/)
is a good overview of its scope, involving four main organisms (human, mouse, worm
and fly) and dozens of biotechnological innovations that
are used to analyze gene structure and
regulation.  In this section we will illustrate ways of using Bioconductor
to acquire and interpret ENCODE resources.

# Built-in surveys through ENCODExplorer metadata

We can use AnnotationHub to get information on ENCODE results that have
been curated for direct use with Bioconductor.  The
`r Biocpkg("ENCODExplorer")` package provides a metadata table,
that we retrieve using `r Biocpkg("AnnotationHub")`.  We use
the "full" table because it provides links to raw and processed data files
curated in the cloud by the ENCODE project.  

## Using a local metadata cache 

This table is over 90MB in
size, so it takes a few moments to download from cloud or load from cache.

```{r doen1,cache=TRUE}
library(AnnotationHub)
ah = AnnotationHub()
query(ah, "ENCODExplorerData")
fm = ah[["AH75132"]]
dim(fm)
table(fm$organism)
```

## Filtering the metadata table

We focus on human samples, and limit to ChIP-seq
experiments for now.
```{r doen2, cache=TRUE}
# filter
hfm = fm[which(fm$organism == "Homo sapiens"),]
tail(sort(table(hfm$assay)))
hfmt = hfm[which(hfm$assay == "TF ChIP-seq"),]
```

The proteins for which binding patterns can be
assessed are in the `antibody_target` field:
```{r lkst}
tail(sort(table(hfmt$antibody_target)))
```

## Managing the information with a GenomicFiles instance 

We'll manage the ChIP-seq data references with a
`r Biocpkg("GenomicFiles")` object.
For convenience, we'll focus on bigWig files.

```{r dolim}
hfmtbw = hfmt[hfmt$file_type == "bigWig",]
dim(hfmtbw)
table(hfmtbw$output_type)
```
<!--
Note that IDR denotes "irreproducible discovery rate" a measure of
confidence [developed within ENCODE](https://genome.ucsc.edu/ENCODE/qualityMetrics.html).
-->
```{r dogf}
library(GenomicFiles)
gf1 = GenomicFiles(files=hfmtbw$cloud_metadata.url)
colData(gf1) = as(as.data.frame(hfmtbw), "DataFrame")
table(gf1$assembly)
```
This last table is very important, indicating that we are managing information
for which two genomic coordinate systems are in play.  In the introduction
to Bioconductor, it is shown
how `liftOver` can be used to translate between coordinate systems if needed.

We'll focus on data collected with GRCh38 coordinates.
```{r limg}
gf1 = gf1[, which(gf1$assembly == "GRCh38")]
gf1
gf = GenomicFiles(files=hfmtbw$cloud_metadata.url)
colData(gf) = as(as.data.frame(hfmtbw), "DataFrame")
```

## Anatomic sources of samples

We'll define a helper function to report on discrete properties
of samples.  This gives us clues on the contents of listings of biosample type and
associated ontology labels.
```{r lktls}
tls = function(x) tail(sort(table(x)))
tls(gf1$biosample_name)
tls(gf1$biosample_ontology)
```

The use of ontology labeling helps us to organize information on samples.
Bioconductor's `r Biocpkg("ontoProc")` package can be used to
develop a simple hierarchical display.  We focus on the Experimental Factor
Ontology (EFO) tags, and take a very small subset of tags in use to
obtain a tractable display in this document.
```{r lkontopl}
library(ontoProc)
ee = getEFOOnto()
tail(sort(table(hfmt$biosample_ontology)),12) -> ioi
nn = names(ioi[grep("EFO", names(ioi))])
tails = gsub(".*_", "", nn)
tailss = gsub("/", "", tails)
tt = paste0("EFO:", tailss)
onto_plot2(ee, tt, cex=.6)
```

## Targeted sketching of peak scores

We'll focus on the transcription factor CREB1.
There are a modest number of samples in different
cell lines.  Some are treated with ethanol.
```{r lktr}
gf1_creb1 = gf1[, which(gf1$target == "CREB1")]
table(gf1_creb1$treatment, gf1_creb1$biosample_name, exclude=NULL)
```
We'll focus on samples with type `signal p-value`.
```{r lkopt}
table(gf1_creb1$output_type, gf1_creb1$biosample_name, exclude=NULL)
gf1_creb1_use = gf1_creb1[, 
   which(gf1_creb1$output_type == "signal p-value")]
```
We will import a megabase of bigWig content from the
files selected in this way, using `reduceByFile`:
```{r dored,cache=TRUE}
myr = GRanges("chr17", IRanges(66e6,67e6))
genome(myr) = "GRCh38"
rowRanges(gf1_creb1_use) = myr
sels = reduceByFile(gf1_creb1_use, MAP=function(range, file, ...) {
    sel = BigWigSelection(range)
    import.bw(file, selection=sel, genome=genome(myr)[1])
})
```
Here is our targeted sketch:
```{r lkres1}
lk1 = sels[[1]][[1]]
lk2 = sels[[2]][[1]]
plot(start(lk1)+.5*(width(lk1)), lk1$score, pch=19,
 xlab="midpoint of scored interval, chr17", ylab="-log10 CREB1 signal p-value",
 cex=.5, col=lava::Col("black", alpha=.3))
points(start(lk2)+.5*width(lk2), lk2$score, pch=19, 
 col=lava::Col("blue", alpha=.3), cex=.5)
```

## Exercises

### Retention of metadata

The following function, annotated in roxygen format,
gathers the task of filtering bigWig data of a specific
output type and target in a given genomic interval.

```{r doimpsource}
#' import bigwig in an interval, given GenomicFiles for ENCODE bigWig files
#' @param gf GenomicFiles instance
#' @param target character(1) ChIP-seq target
#' @param output_type character(1) defaults to "signal p-value"
#' @param selection GRanges instance, one range allowed
#' @export
 import_enc_bw = function(gf, target="CREB1", output_type="signal p-value",
   selection= GRanges("chr17", IRanges(66e6,67e6), genome="GRCh38")) {
  stopifnot(length(selection)==1)
  gf_use = gf[, which(gf$target == target)]
  gf_use = gf_use[, 
     which(gf_use$output_type == "signal p-value")]
  rowRanges(gf_use) = selection
  ans = reduceByFile(gf_use, MAP=function(range, file, ...) {
      sel = BigWigSelection(range)
      import.bw(file, selection=sel, genome=genome(myr)[1])
  })
  ans = GRangesList(unlist(ans, recursive=FALSE))
  mcols(ans) = colData(gf_use)
  ans
}
```
We can generate our sketch data with a simple call,
assuming the construction of `gf1` is accomplished as
above.
```{r redosk,cache=TRUE}
skd = import_enc_bw(gf1)
```
A virtue of this approach is that the cell types (and
all metadata) are bound to the scores:
```{r lkskmet}
table(mcols(skd)$biosample_name)
```
